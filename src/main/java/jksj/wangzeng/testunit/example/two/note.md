## 实际重构案例
1. IdGenerator没有设计成接口的实现，调用者直接依赖了实现类，违反基于接口而非实现类编程的设计思想。当系统要
维护两个或多个Id生成规则时，定义接口就比较必要了
2. 将IdGenerator的generator()函数设计成静态函数，会影响使用该函数的代码的可测试性。同时,generator()函数的
代码实现依赖运行环境(本机名)、时间函数、随机函数，所以generator()函数本身的可测试性不好，需要做较大的重构。
且本函数也没有对应的单元测试代码，我们需要在重构时对其补充
3. generator()函数的行数不多，但代码的可读性并不好，特别是随机字符串生成的那部分代码，一方面，代码完全没有
注释，生成算法比较难读懂，另一方面有很多的魔法数，严重影响代码的可读性，在重构时需要重点提高这部分代码的可读性

4. 并未处理hostName为空的情况
5. 每次生成ID都需要获取本机名，获取主机名会比较耗时，所以这部分可以考虑优化一下
6. randomAscii的范围是0-122，但可用数字仅包含三段区间(0-9 a-z A-Z),极端情况下会随机生成很多三段区间之外的无效数字，需要循环多次才能生成随机字符串，所以随机字符串的生成算法也可以优化一下


## 代码审视规则
- 目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？
- 是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？
- 设计模式是否应用得当？是否有过度设计？
- 代码是否容易扩展？如果要添加新功能，是否容易实现？
- 代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？
- 代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？
- 代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？

## 代码功能与非功能性需求审视规则
- 代码是否实现了预期的业务需求？
- 逻辑是否正确？是否处理了各种异常情况？
- 日志打印是否得当？是否方便 debug 排查问题？
- 接口是否易用？是否支持幂等、事务等？
- 代码是否存在并发问题？是否线程安全？
- 性能是否有优化空间，比如，SQL、算法是否可以优化？
- 是否有安全漏洞？比如输入输出校验是否全面？


## 重构步骤
1. 提高代码的可读性
2. 提高代码的可测试性
3. 编写完善的测试用例
4. 所有重构完成之后添加注释


## 开发思想
1. 即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。我们要对代码质量有所追求，不能只是凑活能用就好。花点心思写一段高质量的代码，比写 100 段凑活能用的代码，对你的代码能力提高更有帮助。
2. 知其然知其所以然，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。知道为什么这么做，比单纯地知道怎么做更重要，这样可以避免你过度使用设计模式、思想和原则。
3. 设计思想、原则、模式本身并没有太多“高大上”的东西，都是一些简单的道理，而且知识点也并不多，关键还是锻炼具体代码具体分析的能力，把知识点恰当地用在项目中。
4. 我经常讲，高手之间的竞争都是在细节。大的架构设计、分层、分模块思路实际上都差不多。没有项目是靠一些不为人知的设计来取胜的，即便有，很快也能被学习过去。所以，关键还是看代码细节处理得够不够好。这些细节的差别累积起来，会让代码质量有质的差别。所以，要想提高代码质量，还是要在细节处下功夫。课堂讨论
