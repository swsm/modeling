## 1. 描述程序的好坏
1. 可维护性(maintainability)
2. 可读性(readability)
3. 可扩展性(extensibility)
4. 灵活性(flexibility)
5. 简洁性(simplicity)
6. 可复用性(reusability)
8. 可测试性(testability)

## 2.面向对象
### 2.1 面向对象4大特性
1. 封装   隐藏信息保护数据
2. 抽象   如何隐藏方法的具体实现，让调用者只关心方法提供了哪些功能
3. 继承   表示类之间的is-a关系
4. 多态

### 2.2 设计原则
1. SRP 单一职责原则
2. OCP 开放关闭原则
3. LSP 里氏替换原则
4. ISP 接口隔离原则
5. DIP 依赖倒置原则
6. DRY 原则、KISS原则、YAGNI原则、LOD原则

### 2.3 设计模式
#### 2.3.1 创建型
常用的有: 单例模式、工厂模式(工厂方法和抽象工厂)、建造者模式
不常用的有：原型模式
#### 2.3.2 结构型
常用的有：代理模式、桥接模式、装饰器模式、适配器模式
不常用的有：门面模式、组合模式、享元模式
#### 2.3.3 行为型
常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式
不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式

### 2.4 哪些代码看似是面向对象，实际是面向过程
1. 滥用getter、setter方法
2. 滥用全局变量和全局方法
3. 定义数据和方法分离的类

### 2.5 基于接口而非实现编程
1. 函数的命名不能暴露任何实现细节，比如，前面提到的uploadToAliyun()就不符合要求，应该改为去掉aliyun这样的字眼，改为更加抽象的命名方式，比如：upload()
2. 封装具体的实现细节。比如，跟阿里云相关的特殊上传(或下载)流程不应该暴露给调用者。我们对上传(或下载)流程进行封装，du对外提供一个包裹所有上传(或下载)细节的方法，给调用者使用
3. 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程

### 2.6 贫血模型和充血模型
基于贫血模型的传统开发方式-重Service轻BO;
基于充血模型的DDD开发模式-轻Serivce重Domain

### 2.6.1 适用面
基于贫血模型的开发模式，比较适合业务比较简单的系统开发。
基于充血模型的DDD开发模式，更适合业务复杂的系统开发，比如包含各种利息计算模型、还款模型等复杂业务的金融系统


### 3. 设计原则详细内容
#### 3.1 SRP
##### 3.1.1 实际方法
1. 我们可以先写一个粗粒度的类，满足业务需求，随着业务发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将
这个粗粒度的类，拆分成几个更细粒度的类，这就是所谓的持续重构

##### 3.1.2 判断原则
1. 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；
2. 类依赖的其它类过多，或者依赖类的其它类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；
3. 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性；
4. 比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、context之类的词语来命名，这就说明类的
职责定义得可能不够清晰
5. 类中大量得方法都是集中操作类中得几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将
这几个属性对应的方法拆分出来


#### 3.2 OCP
##### 3.2.1 指导思想
1. 我们要时刻具备扩展意识、抽象意识、封装意识。这些意识可能比任何开发技巧都重要

简述：在写代码的时候，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构、事先留好扩展点，以便
在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到"对扩展开放，
对修改关闭"。  -----   还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变
接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游
系统的代码几乎不需要修改


##### 3.2.2 实际方法
1. 使用handler方法： 定义抽象handler 定义子handler类，然后将操作变成使用特定的handler

#### 3.3 LSP
子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

#### 3.4.ISP
客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者

#### 3.5 DIP
高层模块不要依赖低层模块，高层模块和底层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，
具体实现细节依赖抽象

##### 3.5.1 控制反转 IOC
流程的控制权从程序员反转到了框架

##### 3.5.2 依赖注入 DI
不通过new()的方式在类内部创建依赖对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式
传递或注入给类使用

#### 3.6 DRY
##### 3.6.1 代码复用性
1. 减少代码耦合
2. 满足单一职责原则
3. 模块化
4. 业务与非业务逻辑分离
5. 通用代码下沉
6. 继承、多态、抽象、封装
7. 应用模板等设计模式

#### 3.7 LOD
不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口


### 4. 重构
大型重构是指对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、
解耦、抽象可复用组件等等。这类重构的工具j就是我们学习过的设计思想，原则和模式。

小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、
提取重复代码等等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识

### 4.1 单元测试
研发工程师来编写，写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程

